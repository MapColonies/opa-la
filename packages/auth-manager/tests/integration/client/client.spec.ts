/// <reference types="jest-extended" />
import jsLogger from '@map-colonies/js-logger';
import { trace } from '@opentelemetry/api';
import httpStatusCodes from 'http-status-codes';
import { DependencyContainer } from 'tsyringe';
import { faker } from '@faker-js/faker';
import 'jest-openapi';
import { DataSource } from 'typeorm';
import { Client, IClient } from '@map-colonies/auth-core';
import { createRequestSender, RequestSender } from '@map-colonies/openapi-helpers/requestSender';
import { paths, operations } from '@openapi';
import { getApp } from '@src/app';
import { SERVICES } from '@common/constants';
import { getFakeClient } from '@tests/utils/client';
import { initConfig } from '@common/config';
import { ClientRepository } from '@src/client/DAL/clientRepository';

describe('client', function () {
  let requestSender: RequestSender<paths, operations>;
  let depContainer: DependencyContainer;

  beforeAll(async function () {
    await initConfig();
    const [app, container] = await getApp({
      override: [
        { token: SERVICES.LOGGER, provider: { useValue: jsLogger({ enabled: false }) } },
        { token: SERVICES.TRACER, provider: { useValue: trace.getTracer('testTracer') } },
      ],
      useChild: true,
    });
    requestSender = await createRequestSender<paths, operations>('openapi3.yaml', app);
    depContainer = container;
  });

  afterAll(async function () {
    await depContainer.resolve(DataSource).destroy();
  });

  describe('Happy Path', function () {
    describe('GET /client', function () {
      afterEach(async function () {
        const connection = depContainer.resolve(DataSource);
        await connection.getRepository(Client).clear();
      });

      it('should return 200 status code and a list of clients', async function () {
        const clients = [getFakeClient(false), getFakeClient(false)];

        const connection = depContainer.resolve(DataSource);
        await connection.getRepository(Client).insert(clients.map((c) => ({ ...c })));

        const res = await requestSender.getClients();

        expect(res).toHaveProperty('status', httpStatusCodes.OK);
        expect(res).toSatisfyApiSpec();
        // @ts-expect-error need to solve as openapi-helpers is not typed correctly
        expect(res.body.items).toIncludeAllPartialMembers(clients);
      });

      it('should support filtering by dates', async function () {
        const clients = [
          { ...getFakeClient(false), createdAt: new Date('2022-12-01') },
          { ...getFakeClient(false), createdAt: new Date('2023-01-01') },
          { ...getFakeClient(false), createdAt: new Date('2023-02-01') },
        ];
        const connection = depContainer.resolve(DataSource);
        await connection.getRepository(Client).insert(clients.map((c) => ({ ...c })));
        const res = await requestSender.getClients({
          queryParams: {
            createdAfter: new Date('2022-12-31').toISOString(),
            createdBefore: new Date('2023-03-31').toISOString(),
          },
        });
        expect(res).toHaveProperty('status', httpStatusCodes.OK);
        expect(res).toSatisfyApiSpec();
        // @ts-expect-error need to solve as openapi-helpers is not typed correctly
        expect(res.body.items).toBeArrayOfSize(2);
      });

      it('should support basic pagination with page and pageSize', async function () {
        // Generated by Copilot
        const TOTAL_CLIENTS = 5;
        const PAGE_SIZE = 2;
        const TARGET_PAGE = 1;

        const clients = Array.from({ length: TOTAL_CLIENTS }, (_, index) => ({
          ...getFakeClient(false),
          name: `pagination-client-${String(index).padStart(2, '0')}`,
        }));

        const connection = depContainer.resolve(DataSource);
        await connection.getRepository(Client).insert(clients.map((c) => ({ ...c })));

        const res = await requestSender.getClients({
          queryParams: {
            page: TARGET_PAGE,
            pageSize: PAGE_SIZE,
          },
        });

        expect(res).toHaveProperty('status', httpStatusCodes.OK);
        expect(res).toSatisfyApiSpec();
        // @ts-expect-error need to solve as openapi-helpers is not typed correctly
        expect(res.body.items).toBeArrayOfSize(PAGE_SIZE);
        // @ts-expect-error need to solve as openapi-helpers is not typed correctly
        expect(res.body.total).toBe(TOTAL_CLIENTS);
      });

      it('should support pagination with different page numbers', async function () {
        // Generated by Copilot
        const TOTAL_CLIENTS = 7;
        const PAGE_SIZE = 3;
        const SECOND_PAGE = 2;

        const clients = Array.from({ length: TOTAL_CLIENTS }, (_, index) => ({
          ...getFakeClient(false),
          name: `page-test-client-${String(index).padStart(2, '0')}`,
        }));

        const connection = depContainer.resolve(DataSource);
        await connection.getRepository(Client).insert(clients.map((c) => ({ ...c })));

        const res = await requestSender.getClients({
          queryParams: {
            page: SECOND_PAGE,
            pageSize: PAGE_SIZE,
          },
        });

        expect(res).toHaveProperty('status', httpStatusCodes.OK);
        expect(res).toSatisfyApiSpec();
        // @ts-expect-error need to solve as openapi-helpers is not typed correctly
        expect(res.body.items).toBeArrayOfSize(PAGE_SIZE);
        // @ts-expect-error need to solve as openapi-helpers is not typed correctly
        expect(res.body.total).toBe(TOTAL_CLIENTS);
      });

      it('should handle last page with fewer items', async function () {
        // Generated by Copilot
        const TOTAL_CLIENTS = 5;
        const PAGE_SIZE = 3;
        const LAST_PAGE = 2;
        const EXPECTED_ITEMS_ON_LAST_PAGE = 2;

        const clients = Array.from({ length: TOTAL_CLIENTS }, (_, index) => ({
          ...getFakeClient(false),
          name: `last-page-client-${String(index).padStart(2, '0')}`,
        }));

        const connection = depContainer.resolve(DataSource);
        await connection.getRepository(Client).insert(clients.map((c) => ({ ...c })));

        const res = await requestSender.getClients({
          queryParams: {
            page: LAST_PAGE,
            pageSize: PAGE_SIZE,
          },
        });

        expect(res).toHaveProperty('status', httpStatusCodes.OK);
        expect(res).toSatisfyApiSpec();
        // @ts-expect-error need to solve as openapi-helpers is not typed correctly
        expect(res.body.items).toBeArrayOfSize(EXPECTED_ITEMS_ON_LAST_PAGE);
        // @ts-expect-error need to solve as openapi-helpers is not typed correctly
        expect(res.body.total).toBe(TOTAL_CLIENTS);
      });

      it('should support sorting by name in ascending order', async function () {
        // Generated by Copilot
        const clientNames = ['zebra-client', 'alpha-client', 'beta-client'];
        const sortedNames = ['alpha-client', 'beta-client', 'zebra-client'];

        const clients = clientNames.map((name) => ({
          ...getFakeClient(false),
          name,
        }));

        const connection = depContainer.resolve(DataSource);
        await connection.getRepository(Client).insert(clients.map((c) => ({ ...c })));

        const res = await requestSender.getClients({
          queryParams: {
            sort: ['name:asc'],
          },
        });

        expect(res).toHaveProperty('status', httpStatusCodes.OK);
        expect(res).toSatisfyApiSpec();
        // @ts-expect-error need to solve as openapi-helpers is not typed correctly
        expect(res.body.items).toHaveLength(clientNames.length);

        // Check if items are sorted correctly
        for (let i = 0; i < sortedNames.length; i++) {
          // @ts-expect-error need to solve as openapi-helpers is not typed correctly
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          expect(res.body.items[i].name).toBe(sortedNames[i]);
        }
      });

      it('should support sorting by name in descending order', async function () {
        // Generated by Copilot
        const clientNames = ['alpha-client', 'zebra-client', 'beta-client'];
        const sortedNamesDesc = ['zebra-client', 'beta-client', 'alpha-client'];

        const clients = clientNames.map((name) => ({
          ...getFakeClient(false),
          name,
        }));

        const connection = depContainer.resolve(DataSource);
        await connection.getRepository(Client).insert(clients.map((c) => ({ ...c })));

        const res = await requestSender.getClients({
          queryParams: {
            sort: ['name:desc'],
          },
        });

        expect(res).toHaveProperty('status', httpStatusCodes.OK);
        expect(res).toSatisfyApiSpec();
        // @ts-expect-error need to solve as openapi-helpers is not typed correctly
        const items = res.body.items as IClient[];
        expect(items).toHaveLength(clientNames.length);

        // Check if items are sorted correctly in descending order
        for (let i = 0; i < sortedNamesDesc.length; i++) {
          // @ts-expect-error need to solve as openapi-helpers is not typed correctly
          expect(items[i].name).toBe(sortedNamesDesc[i]);
        }
      });

      it('should support sorting by createdAt in ascending order', async function () {
        // Generated by Copilot
        const dates = [new Date('2023-01-01'), new Date('2023-03-01'), new Date('2023-02-01')];

        const clients = dates.map((date, index) => ({
          ...getFakeClient(false),
          name: `date-client-${index}`,
          createdAt: date,
        }));

        const connection = depContainer.resolve(DataSource);
        await connection.getRepository(Client).insert(clients.map((c) => ({ ...c })));

        const res = await requestSender.getClients({
          queryParams: {
            sort: ['created-at:asc'],
          },
        });

        expect(res).toHaveProperty('status', httpStatusCodes.OK);
        expect(res).toSatisfyApiSpec();
        // @ts-expect-error need to solve as openapi-helpers is not typed correctly
        expect(res.body.items).toHaveLength(dates.length);

        // Check if items are sorted by createdAt in ascending order
        // @ts-expect-error need to solve as openapi-helpers is not typed correctly
        const sortedItems = res.body.items as Client[];
        for (let i = 0; i < sortedItems.length - 1; i++) {
          // Generated by Copilot
          const currentItem = sortedItems[i];
          const nextItem = sortedItems[i + 1];

          // Ensure createdAt exists before creating Date objects
          if (!currentItem?.createdAt || !nextItem?.createdAt) {
            throw new Error('createdAt is required for date comparison');
          }

          const currentDate = new Date(currentItem.createdAt);
          const nextDate = new Date(nextItem.createdAt);
          expect(currentDate.getTime()).toBeLessThanOrEqual(nextDate.getTime());
        }
      });

      it('should combine pagination and sorting', async function () {
        // Generated by Copilot
        const TOTAL_CLIENTS = 6;
        const PAGE_SIZE = 2;
        const TARGET_PAGE = 2;

        const clients = Array.from({ length: TOTAL_CLIENTS }, (_, index) => ({
          ...getFakeClient(false),
          name: `combo-client-${String(index).padStart(2, '0')}`,
        }));

        const connection = depContainer.resolve(DataSource);
        await connection.getRepository(Client).insert(clients.map((c) => ({ ...c })));

        const res = await requestSender.getClients({
          queryParams: {
            page: TARGET_PAGE,
            pageSize: PAGE_SIZE,
            sort: ['name:asc'],
          },
        });

        expect(res).toHaveProperty('status', httpStatusCodes.OK);
        expect(res).toSatisfyApiSpec();
        // @ts-expect-error need to solve as openapi-helpers is not typed correctly
        const returnedItems = res.body.items as IClient[];
        expect(returnedItems).toBeArrayOfSize(PAGE_SIZE);
        // @ts-expect-error need to solve as openapi-helpers is not typed correctly
        expect(res.body.total).toBe(TOTAL_CLIENTS); // Verify the specific items on page 2 with sorting
        const isFirstItemCorrect = returnedItems[0]?.name === 'combo-client-02';
        const isSecondItemCorrect = returnedItems[1]?.name === 'combo-client-03';

        expect(isFirstItemCorrect).toBe(true);
        expect(isSecondItemCorrect).toBe(true);
      });

      it('should return empty results for page beyond available data', async function () {
        // Generated by Copilot
        const TOTAL_CLIENTS = 3;
        const PAGE_SIZE = 5;
        const BEYOND_AVAILABLE_PAGE = 2;

        const clients = Array.from({ length: TOTAL_CLIENTS }, (_, index) => ({
          ...getFakeClient(false),
          name: `empty-test-client-${index}`,
        }));

        const connection = depContainer.resolve(DataSource);
        await connection.getRepository(Client).insert(clients.map((c) => ({ ...c })));

        const res = await requestSender.getClients({
          queryParams: {
            page: BEYOND_AVAILABLE_PAGE,
            pageSize: PAGE_SIZE,
          },
        });

        expect(res).toHaveProperty('status', httpStatusCodes.OK);
        expect(res).toSatisfyApiSpec();
        // @ts-expect-error need to solve as openapi-helpers is not typed correctly
        expect(res.body.items).toBeArrayOfSize(0);
        // @ts-expect-error need to solve as openapi-helpers is not typed correctly
        expect(res.body.total).toBe(TOTAL_CLIENTS);
      });

      it('should return 201 status code and the created client', async function () {
        const client = getFakeClient(false);

        const res = await requestSender.createClient({ requestBody: client });

        expect(res).toHaveProperty('status', httpStatusCodes.CREATED);
        expect(res).toSatisfyApiSpec();
        expect(res.body).toMatchObject(client);
      });
    });

    describe('GET /client/:clientName', function () {
      it('should return 200 status code and the client', async function () {
        const client = getFakeClient(false);

        const connection = depContainer.resolve(DataSource);
        await connection.getRepository(Client).insert({ ...client });

        const res = await requestSender.getClient({ pathParams: { clientName: client.name } });

        expect(res).toHaveProperty('status', httpStatusCodes.OK);
        expect(res).toSatisfyApiSpec();
        expect(res.body).toMatchObject(client);
      });
    });

    describe('PATCH /client/:clientName', function () {
      it('should return 200 status code and the updated client', async function () {
        const client = getFakeClient(false);

        const connection = depContainer.resolve(DataSource);
        await connection.getRepository(Client).insert({ ...client });

        const res = await requestSender.updateClient({
          pathParams: { clientName: client.name },
          requestBody: { ...client, description: 'xd', tags: ['a', 'b'] },
        });

        expect(res).toHaveProperty('status', httpStatusCodes.OK);
        expect(res).toSatisfyApiSpec();
        expect(res.body).toMatchObject({ ...client, description: 'xd', tags: ['a', 'b'] });
      });
    });
  });

  describe('Bad Path', function () {
    describe('POST /client', function () {
      it('should return 400 status code if the name is too short', async function () {
        const client = getFakeClient(false);
        client.name = 'a';

        const res = await requestSender.createClient({ requestBody: client });

        expect(res).toHaveProperty('status', httpStatusCodes.BAD_REQUEST);
        expect(res).toSatisfyApiSpec();
        expect(res.body).toStrictEqual({ message: 'request/body/name must NOT have fewer than 2 characters' });
      });

      it('should return 400 status code if the name is too long', async function () {
        const client = getFakeClient(false);
        client.name = faker.string.alpha(33);

        const res = await requestSender.createClient({ requestBody: client });

        expect(res).toHaveProperty('status', httpStatusCodes.BAD_REQUEST);
        expect(res).toSatisfyApiSpec();
        expect(res.body).toStrictEqual({ message: 'request/body/name must NOT have more than 32 characters' });
      });

      it('should return 409 status code if client with the same name already exists', async function () {
        const client = getFakeClient(false);

        const res1 = await requestSender.createClient({ requestBody: client });

        expect(res1).toHaveProperty('status', httpStatusCodes.CREATED);

        const res2 = await requestSender.createClient({ requestBody: client });

        expect(res2).toHaveProperty('status', httpStatusCodes.CONFLICT);
        expect(res2).toSatisfyApiSpec();
        expect(res2.body).toStrictEqual({ message: 'client already exists' });
      });
    });
    describe('GET /client/:clientName', function () {
      it('should return 404 status code if the client was not found', async function () {
        const res = await requestSender.getClient({ pathParams: { clientName: 'lol' } });

        expect(res).toHaveProperty('status', httpStatusCodes.NOT_FOUND);
        expect(res).toSatisfyApiSpec();
        expect(res.body).toStrictEqual({ message: "A client with the given name doesn't exists in the database" });
      });
    });

    describe('PATCH /client/:clientName', function () {
      it('should return 404 status code if the client was not found', async function () {
        const client = getFakeClient(false);

        const res = await requestSender.updateClient({
          pathParams: { clientName: 'lol' },
          requestBody: client,
        });

        expect(res).toHaveProperty('status', httpStatusCodes.NOT_FOUND);
        expect(res).toSatisfyApiSpec();
        expect(res.body).toStrictEqual({ message: 'client with given name was not found' });
      });
    });
  });
  describe('Sad Path', function () {
    afterEach(function () {
      jest.restoreAllMocks();
    });

    describe('GET /client', function () {
      it('should return 500 status code if db throws an error', async function () {
        const repo = depContainer.resolve<ClientRepository>(SERVICES.CLIENT_REPOSITORY);
        jest.spyOn(repo, 'findAndCount').mockRejectedValue(new Error());

        const res = await requestSender.getClients();

        expect(res).toHaveProperty('status', httpStatusCodes.INTERNAL_SERVER_ERROR);
        expect(res).toSatisfyApiSpec();
      });
    });
    describe('POST /client', function () {
      it('should return 500 status code if db throws an error', async function () {
        const repo = depContainer.resolve<ClientRepository>(SERVICES.CLIENT_REPOSITORY);
        jest.spyOn(repo, 'insert').mockRejectedValue(new Error());

        const res = await requestSender.createClient({ requestBody: getFakeClient(false) });

        expect(res).toHaveProperty('status', httpStatusCodes.INTERNAL_SERVER_ERROR);
        expect(res).toSatisfyApiSpec();
      });

      describe('GET /client/:clientName', function () {
        it('should return 500 status code if db throws an error', async function () {
          const repo = depContainer.resolve<ClientRepository>(SERVICES.CLIENT_REPOSITORY);
          jest.spyOn(repo, 'findOne').mockRejectedValue(new Error());

          const res = await requestSender.getClient({ pathParams: { clientName: 'avi' } });

          expect(res).toHaveProperty('status', httpStatusCodes.INTERNAL_SERVER_ERROR);
          expect(res).toSatisfyApiSpec();
        });
      });

      describe('PATCH /client/:clientName', function () {
        it('should return 500 status code if db throws an error', async function () {
          const repo = depContainer.resolve<ClientRepository>(SERVICES.CLIENT_REPOSITORY);
          jest.spyOn(repo, 'updateAndReturn').mockRejectedValue(new Error());

          const res = await requestSender.updateClient({
            pathParams: { clientName: 'avi' },
            requestBody: getFakeClient(false),
          });

          expect(res).toHaveProperty('status', httpStatusCodes.INTERNAL_SERVER_ERROR);
          expect(res).toSatisfyApiSpec();
        });
      });
    });
  });
});
